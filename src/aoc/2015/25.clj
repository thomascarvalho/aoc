^{:nextjournal.clerk/visibility :hide-ns}
(ns aoc.2015.25
  {:nextjournal.clerk/toc true}
  (:require [clojure.java.io :as io]
            [nextjournal.clerk :as clerk]
            [clojure.core.match :refer [match]]
            [clojure.core.matrix :as ma]
            [util :as u]
            [clojure.test :refer :all]))

;; # Problem
;; {:nextjournal.clerk/visibility {:code :hide :result :show}}
;; (clerk/html (u/load-problem "25" "2015"))
;; {:nextjournal.clerk/visibility {:code :show :result :show}}

;; # Solution
;;
;; First things first, let's load our input and parse it

(defn parser [data]
  (->> data
       u/parse-out-longs
       (mapv dec)))

(def input (->> (slurp (io/resource "inputs/2015/25.txt")) ;; Load the resource
                parser))                             ;; Split into lines
{:nextjournal.clerk/visibility {:result :hide}}

;; The voice on the other end of the phone continues with how the codes are actually generated.
;; The first code is 20151125. After that, each code is generated by taking the previous one,
;; multiplying it by 252533, and then keeping the remainder from dividing that value by 33554393.

;; So, to find the second code (which ends up in row 2, column 1), start with the previous value,
;; 20151125. Multiply it by 252533 to get 5088824049625.
;; Then, divide that by 33554393, which leaves a remainder of 31916031. 
;; That remainder is the second code.

(defn get-value [previous]
  (as-> previous $
    (* 252533 $)
    (rem $ 33554393)))

;; ## Part 1
(defn part-1
  [[row column]]
  (let [size   (* 2 (max row column))
        m-init (ma/new-matrix size size)]
    (->
     (loop [m              m-init
            [y x]          [0 0]
            previous-value nil]
       (if (> y (dec size))
         m
         (let [next-pos (match [y x]
                          [0 0]  [(inc y) x]
                          [_ 0]  [(dec y) (inc x)]
                          [0 _]  [(inc x) 0]
                          [_ _]  [(dec y) (inc x)])
               value    (if (= [y x] [0 0])
                          20151125
                          (get-value previous-value))]
           (recur
            (ma/mset m y x value)
            next-pos
            value))))
     (ma/mget row column))))

;; Which gives our answer
{:nextjournal.clerk/visibility {:code   :hide
                                :result :show}}
(part-1 input)

;; ## Part 2
{:nextjournal.clerk/visibility {:code   :show
                                :result :hide}}
(defn part-2
  [input]

  ;
  )

;; Which gives our answer
{:nextjournal.clerk/visibility {:code   :hide
                                :result :show}}
#_(part-2 input)


;; # Tests
{:nextjournal.clerk/visibility {:code   :show
                                :result :hide}}

;; ## Suite
(deftest test-2015-25
  (testing "part one"
    (is (= 9132360 (part-1 input))))

  #_(testing "part two"
      (is (= 1 (part-2 input)))))

{:nextjournal.clerk/visibility {:code   :hide
                                :result :show}}
;; ## Results